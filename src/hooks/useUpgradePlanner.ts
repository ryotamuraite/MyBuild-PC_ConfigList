// src/hooks/useUpgradePlanner.ts
// Phase 3 Week2: „Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„Éâ„Éó„É©„É≥„Éä„ÉºÂ∞ÇÁî®React„Éï„ÉÉ„ÇØ

import { useState, useCallback, useRef } from 'react';
import {
  BottleneckAnalysis,
  UpgradeRecommendation,
  UpgradeSimulationConfig,
  UpgradeSimulationResult,
  UsageScenario,
  PerformanceTarget
} from '../types/upgrade';

// ===========================================
// üéØ „Éï„ÉÉ„ÇØÂûãÂÆöÁæ©
// ===========================================

export interface UpgradePlannerState {
  // „Éó„É©„É≥ÁÆ°ÁêÜ
  availablePlans: UpgradeRecommendation[];
  selectedPlan: UpgradeRecommendation | null;
  customPlan: UpgradeRecommendation | null;
  
  // „Éó„É©„É≥ÊØîËºÉ
  comparisonPlans: UpgradeRecommendation[];
  comparisonResult: ComparisonResult | null;
  
  // „Ç´„Çπ„Çø„É†„Éó„É©„É≥ÁîüÊàê
  isGeneratingCustom: boolean;
  customPlanConfig: CustomPlanConfig;
  
  // „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
  isSimulating: boolean;
  simulationResult: UpgradeSimulationResult | null;
  
  // Áä∂ÊÖãÁÆ°ÁêÜ
  loading: boolean;
  error: string | null;
  
  // „Éó„É©„É≥ÂÆüË°åËøΩË∑°
  executionPlans: ExecutionPlan[];
  activeExecution: ExecutionPlan | null;
  
  // Áµ±Ë®à„ÉªÂàÜÊûê
  plannerStats: PlannerStatistics;
}

export interface UpgradePlannerActions {
  // „Éó„É©„É≥ÁÆ°ÁêÜ
  loadPlans: (analysis: BottleneckAnalysis) => Promise<void>;
  selectPlan: (plan: UpgradeRecommendation) => void;
  clearSelection: () => void;
  
  // „Éó„É©„É≥ÊØîËºÉ
  addToComparison: (plan: UpgradeRecommendation) => void;
  removeFromComparison: (planId: string) => void;
  clearComparison: () => void;
  runComparison: () => Promise<ComparisonResult>;
  
  // „Ç´„Çπ„Çø„É†„Éó„É©„É≥
  updateCustomConfig: (config: Partial<CustomPlanConfig>) => void;
  generateCustomPlan: (analysis: BottleneckAnalysis) => Promise<UpgradeRecommendation>;
  
  // „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥
  runSimulation: (config: UpgradeSimulationConfig) => Promise<UpgradeSimulationResult>;
  
  // „Éó„É©„É≥ÂÆüË°å
  startExecution: (plan: UpgradeRecommendation) => ExecutionPlan;
  updateExecutionProgress: (executionId: string, progress: Partial<ExecutionProgress>) => void;
  completeExecution: (executionId: string, result: ExecutionResult) => void;
  
  // ÊúÄÈÅ©Âåñ
  optimizePlan: (plan: UpgradeRecommendation, constraints: OptimizationConstraints) => Promise<UpgradeRecommendation>;
  
  // „Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éª„Ç§„É≥„Éù„Éº„Éà
  exportPlan: (plan: UpgradeRecommendation, format: 'json' | 'csv' | 'pdf') => string;
  importPlan: (data: string, format: 'json' | 'csv') => UpgradeRecommendation;
  
  // „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
  clearError: () => void;
  resetPlanner: () => void;
  getStatistics: () => PlannerStatistics;
}

// „Ç´„Çπ„Çø„É†„Éó„É©„É≥Ë®≠ÂÆö
export interface CustomPlanConfig {
  budget: {
    min: number;
    max: number;
    preferred: number;
    flexibility: number; // 0-1
  };
  timeframe: {
    immediate: boolean;
    preferredDuration: number; // ÊúàÊï∞
    maxDuration: number;
    phaseInterval: number; // „Éï„Çß„Éº„Ç∫ÈñìÈöîÔºàÊúàÔºâ
  };
  priority: {
    performance: number; // 0-100 Èáç„Åø
    budget: number;
    efficiency: number;
    longevity: number;
    aesthetics: number;
  };
  constraints: {
    maxComplexity: 'simple' | 'moderate' | 'advanced' | 'expert';
    keepParts: string[]; // Á∂≠ÊåÅ„Åó„Åü„ÅÑ„Éë„Éº„ÉÑID
    mustReplaceParts: string[]; // ÂøÖÈ†à‰∫§Êèõ„Éë„Éº„ÉÑID
    avoidManufacturers: string[];
    preferredManufacturers: string[];
  };
  scenarios: UsageScenario[];
  targets: PerformanceTarget[];
}

// „Éó„É©„É≥ÊØîËºÉÁµêÊûú
export interface ComparisonResult {
  plans: UpgradeRecommendation[];
  metrics: ComparisonMetric[];
  ranking: PlanRanking[];
  tradeoffs: TradeoffAnalysis[];
  recommendation: string;
  confidence: number;
}

// ÊØîËºÉÊåáÊ®ô
export interface ComparisonMetric {
  name: string;
  key: string;
  values: { planId: string; value: number; rank: number }[];
  winner: string; // planId
  importance: number; // 0-1
}

// „Éó„É©„É≥„É©„É≥„Ç≠„É≥„Ç∞
export interface PlanRanking {
  planId: string;
  overallScore: number;
  categoryScores: {
    cost: number;
    performance: number;
    roi: number;
    feasibility: number;
    risk: number;
  };
  reasoning: string[];
}

// „Éà„É¨„Éº„Éâ„Ç™„ÉïÂàÜÊûê
export interface TradeoffAnalysis {
  aspect1: string;
  aspect2: string;
  correlation: number; // -1 to 1
  description: string;
  recommendations: string[];
}

// „Éó„É©„É≥ÂÆüË°åËøΩË∑°
export interface ExecutionPlan {
  id: string;
  planId: string;
  plan: UpgradeRecommendation;
  startDate: Date;
  currentPhase: number;
  status: 'planning' | 'in_progress' | 'paused' | 'completed' | 'cancelled';
  progress: ExecutionProgress;
  timeline: ExecutionTimeline[];
  issues: ExecutionIssue[];
  notes: string[];
}

export interface ExecutionProgress {
  overallProgress: number; // 0-100
  phaseProgress: number; // 0-100
  budget: {
    allocated: number;
    spent: number;
    remaining: number;
  };
  timeline: {
    estimatedCompletion: Date;
    actualCompletion?: Date;
    delayDays: number;
  };
  quality: {
    issuesCount: number;
    satisfactionScore: number; // 0-100
  };
}

export interface ExecutionTimeline {
  phase: number;
  phaseName: string;
  status: 'pending' | 'in_progress' | 'completed' | 'skipped';
  startDate?: Date;
  completionDate?: Date;
  actualCost?: number;
  notes?: string;
}

export interface ExecutionIssue {
  id: string;
  type: 'compatibility' | 'installation' | 'performance' | 'cost' | 'delay';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  resolution?: string;
  resolved: boolean;
  reportedAt: Date;
  resolvedAt?: Date;
}

export interface ExecutionResult {
  success: boolean;
  actualImprovement: {
    performance: number;
    efficiency: number;
    userSatisfaction: number;
  };
  actualCost: number;
  actualDuration: number; // Êó•Êï∞
  lessonsLearned: string[];
  recommendations: string[];
}

// ÊúÄÈÅ©ÂåñÂà∂Á¥Ñ
export interface OptimizationConstraints {
  maxBudget?: number;
  maxDuration?: number; // ÊúàÊï∞
  maxComplexity?: string;
  minImprovement?: number; // %
  riskTolerance: 'low' | 'medium' | 'high';
}

// „Éó„É©„É≥„Éä„ÉºÁµ±Ë®à
export interface PlannerStatistics {
  totalPlansGenerated: number;
  avgPlanCost: number;
  avgImprovement: number;
  popularPlanTypes: { type: string; count: number }[];
  userPreferences: {
    avgBudget: number;
    preferredTimeframe: string;
    topPriorities: string[];
  };
  successRates: {
    planCompletion: number; // %
    budgetAdherence: number; // %
    timelineAdherence: number; // %
    userSatisfaction: number; // 0-100
  };
  performance: {
    avgGenerationTime: number; // ms
    cacheHitRate: number; // %
  };
}

// ===========================================
// üöÄ „É°„Ç§„É≥„Éï„ÉÉ„ÇØÂÆüË£Ö
// ===========================================

export const useUpgradePlanner = (): [UpgradePlannerState, UpgradePlannerActions] => {
  
  // ===========================================
  // üìä „Çπ„ÉÜ„Éº„ÉàÁÆ°ÁêÜ
  // ===========================================
  
  const [state, setState] = useState<UpgradePlannerState>({
    availablePlans: [],
    selectedPlan: null,
    customPlan: null,
    comparisonPlans: [],
    comparisonResult: null,
    isGeneratingCustom: false,
    customPlanConfig: {
      budget: {
        min: 30000,
        max: 500000,
        preferred: 100000,
        flexibility: 0.2
      },
      timeframe: {
        immediate: false,
        preferredDuration: 6,
        maxDuration: 12,
        phaseInterval: 2
      },
      priority: {
        performance: 40,
        budget: 30,
        efficiency: 15,
        longevity: 10,
        aesthetics: 5
      },
      constraints: {
        maxComplexity: 'moderate',
        keepParts: [],
        mustReplaceParts: [],
        avoidManufacturers: [],
        preferredManufacturers: []
      },
      scenarios: [],
      targets: []
    },
    isSimulating: false,
    simulationResult: null,
    loading: false,
    error: null,
    executionPlans: [],
    activeExecution: null,
    plannerStats: {
      totalPlansGenerated: 0,
      avgPlanCost: 0,
      avgImprovement: 0,
      popularPlanTypes: [],
      userPreferences: {
        avgBudget: 100000,
        preferredTimeframe: '3-6months',
        topPriorities: ['performance', 'budget']
      },
      successRates: {
        planCompletion: 0,
        budgetAdherence: 0,
        timelineAdherence: 0,
        userSatisfaction: 0
      },
      performance: {
        avgGenerationTime: 0,
        cacheHitRate: 0
      }
    }
  });
  
  // „Ç≠„É£„ÉÉ„Ç∑„É•„Å®„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁÆ°ÁêÜ
  const planCache = useRef<Map<string, UpgradeRecommendation[]>>(new Map());
  const comparisonCache = useRef<Map<string, ComparisonResult>>(new Map());
  const performanceMetrics = useRef({
    generationTimes: [] as number[],
    cacheHits: 0,
    cacheMisses: 0
  });

  // ===========================================
  // üîß „Éò„É´„Éë„ÉºÈñ¢Êï∞
  // ===========================================

  const updateState = useCallback((updates: Partial<UpgradePlannerState> | ((prev: UpgradePlannerState) => Partial<UpgradePlannerState>)) => {
    if (typeof updates === 'function') {
      setState(prev => ({ ...prev, ...updates(prev) }));
    } else {
      setState(prev => ({ ...prev, ...updates }));
    }
  }, []);

  const logPerformance = useCallback((operation: string, startTime: number) => {
    const duration = Date.now() - startTime;
    performanceMetrics.current.generationTimes.push(duration);
    
    // ÊúÄÊñ∞100‰ª∂„ÅÆ„Åø‰øùÊåÅ
    if (performanceMetrics.current.generationTimes.length > 100) {
      performanceMetrics.current.generationTimes.shift();
    }
    
    console.log(`[UpgradePlanner] ${operation}: ${duration}ms`);
  }, []);

  const generateCacheKey = useCallback((analysis: BottleneckAnalysis, config?: any): string => {
    const keyData = {
      score: analysis.overallScore,
      bottlenecks: analysis.bottlenecks.length,
      config: config ? JSON.stringify(config) : null
    };
    return btoa(JSON.stringify(keyData)).replace(/[^a-zA-Z0-9]/g, '');
  }, []);

  // ===========================================
  // üìã „Éó„É©„É≥ÁÆ°ÁêÜÊ©üËÉΩ
  // ===========================================

  const loadPlans = useCallback(async (analysis: BottleneckAnalysis): Promise<void> => {
    const startTime = Date.now();
    
    try {
      updateState({ loading: true, error: null });
      
      // „Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØ
      const cacheKey = generateCacheKey(analysis);
      const cached = planCache.current.get(cacheKey);
      
      if (cached) {
        performanceMetrics.current.cacheHits++;
        updateState({ 
          availablePlans: cached,
          selectedPlan: cached[0] || null,
          loading: false 
        });
        logPerformance('loadPlans (cached)', startTime);
        return;
      }
      
      performanceMetrics.current.cacheMisses++;
      
      // „Éó„É©„É≥ÁîüÊàêÔºàÊó¢Â≠ò„ÅÆupgradeAnalyzer„ÇíÊ¥ªÁî®Ôºâ
      const plans = await generatePlansFromAnalysis(analysis);
      
      // „Ç≠„É£„ÉÉ„Ç∑„É•‰øùÂ≠ò
      planCache.current.set(cacheKey, plans);
      
      updateState({
        availablePlans: plans,
        selectedPlan: plans[0] || null,
        loading: false
      });
      
      logPerformance('loadPlans', startTime);
      
    } catch (error) {
      updateState({
        loading: false,
        error: error instanceof Error ? error.message : '„Éó„É©„É≥Ë™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'
      });
    }
  }, [generateCacheKey, updateState, logPerformance]);

  const selectPlan = useCallback((plan: UpgradeRecommendation) => {
    updateState({ selectedPlan: plan });
  }, [updateState]);

  const clearSelection = useCallback(() => {
    updateState({ selectedPlan: null });
  }, [updateState]);

  // ===========================================
  // ‚öñÔ∏è „Éó„É©„É≥ÊØîËºÉÊ©üËÉΩ
  // ===========================================

  const addToComparison = useCallback((plan: UpgradeRecommendation) => {
    updateState((prev: UpgradePlannerState) => ({
      comparisonPlans: [...prev.comparisonPlans.filter(p => p.id !== plan.id), plan].slice(0, 3)
    }));
  }, [updateState]);

  const removeFromComparison = useCallback((planId: string) => {
    updateState((prev: UpgradePlannerState) => ({
      comparisonPlans: prev.comparisonPlans.filter(p => p.id !== planId)
    }));
  }, [updateState]);

  const clearComparison = useCallback(() => {
    updateState({ comparisonPlans: [], comparisonResult: null });
  }, [updateState]);

  const runComparison = useCallback(async (): Promise<ComparisonResult> => {
    const startTime = Date.now();
    
    try {
      const { comparisonPlans } = state;
      
      if (comparisonPlans.length < 2) {
        throw new Error('ÊØîËºÉ„Å´„ÅØÊúÄ‰Ωé2„Å§„ÅÆ„Éó„É©„É≥„ÅåÂøÖË¶Å„Åß„Åô');
      }
      
      // „Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØ
      const cacheKey = comparisonPlans.map(p => p.id).sort().join('_');
      const cached = comparisonCache.current.get(cacheKey);
      
      if (cached) {
        updateState({ comparisonResult: cached });
        logPerformance('runComparison (cached)', startTime);
        return cached;
      }
      
      // ÊØîËºÉÂàÜÊûêÂÆüË°å
      const result = await performPlanComparison(comparisonPlans);
      
      // „Ç≠„É£„ÉÉ„Ç∑„É•‰øùÂ≠ò
      comparisonCache.current.set(cacheKey, result);
      
      updateState({ comparisonResult: result });
      
      logPerformance('runComparison', startTime);
      
      return result;
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'ÊØîËºÉÂàÜÊûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü';
      updateState({ error: errorMessage });
      throw error;
    }
  }, [state, updateState, logPerformance]);

  // ===========================================
  // üéõÔ∏è „Ç´„Çπ„Çø„É†„Éó„É©„É≥Ê©üËÉΩ
  // ===========================================

  const updateCustomConfig = useCallback((config: Partial<CustomPlanConfig>) => {
    updateState((prev: UpgradePlannerState) => ({
      customPlanConfig: { ...prev.customPlanConfig, ...config }
    }));
  }, [updateState]);

  const generateCustomPlan = useCallback(async (analysis: BottleneckAnalysis): Promise<UpgradeRecommendation> => {
    const startTime = Date.now();
    
    try {
      updateState({ isGeneratingCustom: true, error: null });
      
      const { customPlanConfig } = state;
      
      // „Ç´„Çπ„Çø„É†„Éó„É©„É≥ÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ
      const customPlan = await createCustomPlan(analysis, customPlanConfig);
      
      updateState({
        isGeneratingCustom: false,
        customPlan,
        selectedPlan: customPlan
      });
      
      logPerformance('generateCustomPlan', startTime);
      
      return customPlan;
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : '„Ç´„Çπ„Çø„É†„Éó„É©„É≥ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü';
      updateState({
        isGeneratingCustom: false,
        error: errorMessage
      });
      throw error;
    }
  }, [state, updateState, logPerformance]);

  // ===========================================
  // üéØ „Éó„É©„É≥ÂÆüË°åËøΩË∑°
  // ===========================================

  const startExecution = useCallback((plan: UpgradeRecommendation): ExecutionPlan => {
    const executionPlan: ExecutionPlan = {
      id: `exec_${Date.now()}`,
      planId: plan.id,
      plan,
      startDate: new Date(),
      currentPhase: 0,
      status: 'planning',
      progress: {
        overallProgress: 0,
        phaseProgress: 0,
        budget: {
          allocated: plan.totalCost,
          spent: 0,
          remaining: plan.totalCost
        },
        timeline: {
          estimatedCompletion: new Date(Date.now() + (plan.phases.length * 30 * 24 * 60 * 60 * 1000)), // ÊúàÊï∞„ÇíÊ¶ÇÁÆó
          delayDays: 0
        },
        quality: {
          issuesCount: 0,
          satisfactionScore: 0
        }
      },
      timeline: plan.phases.map((phase, index) => ({
        phase: index + 1,
        phaseName: phase.name,
        status: 'pending'
      })),
      issues: [],
      notes: []
    };
    
    updateState((prev: UpgradePlannerState) => ({
      executionPlans: [...prev.executionPlans, executionPlan],
      activeExecution: executionPlan
    }));
    
    return executionPlan;
  }, [updateState]);

  // ===========================================
  // üõ†Ô∏è „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£Ê©üËÉΩ
  // ===========================================

  const clearError = useCallback(() => {
    updateState({ error: null });
  }, [updateState]);

  const resetPlanner = useCallback(() => {
    setState({
      availablePlans: [],
      selectedPlan: null,
      customPlan: null,
      comparisonPlans: [],
      comparisonResult: null,
      isGeneratingCustom: false,
      customPlanConfig: state.customPlanConfig, // Ë®≠ÂÆö„ÅØ‰øùÊåÅ
      isSimulating: false,
      simulationResult: null,
      loading: false,
      error: null,
      executionPlans: [],
      activeExecution: null,
      plannerStats: state.plannerStats // Áµ±Ë®à„ÅØ‰øùÊåÅ
    });
    
    // „Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢
    planCache.current.clear();
    comparisonCache.current.clear();
  }, [state.customPlanConfig, state.plannerStats]);

  const getStatistics = useCallback((): PlannerStatistics => {
    const avgGenerationTime = performanceMetrics.current.generationTimes.length > 0
      ? performanceMetrics.current.generationTimes.reduce((a, b) => a + b, 0) / performanceMetrics.current.generationTimes.length
      : 0;
    
    const cacheHitRate = (performanceMetrics.current.cacheHits + performanceMetrics.current.cacheMisses) > 0
      ? (performanceMetrics.current.cacheHits / (performanceMetrics.current.cacheHits + performanceMetrics.current.cacheMisses)) * 100
      : 0;
    
    return {
      ...state.plannerStats,
      performance: {
        avgGenerationTime,
        cacheHitRate
      }
    };
  }, [state.plannerStats]);

  // „Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„ÉºÂÆüË£ÖÔºàÁ∞°Áï•ÂåñÔºâ
  const updateExecutionProgress = useCallback((_executionId: string, _progress: Partial<ExecutionProgress>) => {
    // ÂÆüË£ÖÁúÅÁï•
  }, []);

  const completeExecution = useCallback((executionId: string, result: ExecutionResult) => {
    // ÂÆüË£ÖÁúÅÁï•
  }, []);

  const runSimulation = useCallback(async (config: UpgradeSimulationConfig): Promise<UpgradeSimulationResult> => {
    // ÂÆüË£ÖÁúÅÁï• - „Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ê©üËÉΩ„ÅØ Phase 3 Week3 „ÅßÂÆüË£Ö‰∫àÂÆö
    throw new Error('„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ê©üËÉΩ„ÅØ Week3 „ÅßÂÆüË£Ö‰∫àÂÆö„Åß„Åô');
  }, []);

  const optimizePlan = useCallback(async (plan: UpgradeRecommendation, constraints: OptimizationConstraints): Promise<UpgradeRecommendation> => {
    // ÂÆüË£ÖÁúÅÁï•
    return plan;
  }, []);

  const exportPlan = useCallback((plan: UpgradeRecommendation, format: 'json' | 'csv' | 'pdf'): string => {
    // ÂÆüË£ÖÁúÅÁï•
    return JSON.stringify(plan);
  }, []);

  const importPlan = useCallback((data: string, format: 'json' | 'csv'): UpgradeRecommendation => {
    // ÂÆüË£ÖÁúÅÁï•
    return JSON.parse(data);
  }, []);

  // ===========================================
  // üì§ Êàª„ÇäÂÄ§
  // ===========================================

  const actions: UpgradePlannerActions = {
    loadPlans,
    selectPlan,
    clearSelection,
    addToComparison,
    removeFromComparison,
    clearComparison,
    runComparison,
    updateCustomConfig,
    generateCustomPlan,
    runSimulation,
    startExecution,
    updateExecutionProgress,
    completeExecution,
    optimizePlan,
    exportPlan,
    importPlan,
    clearError,
    resetPlanner,
    getStatistics
  };

  return [state, actions];
};

// ===========================================
// üõ†Ô∏è ÂÜÖÈÉ®„Éò„É´„Éë„ÉºÈñ¢Êï∞
// ===========================================

async function generatePlansFromAnalysis(analysis: BottleneckAnalysis): Promise<UpgradeRecommendation[]> {
  // Week1„ÅßÂÆüË£ÖÊ∏à„Åø„ÅÆuseUpgradeRecommendation„ÅÆÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ„ÇíÂÜçÂà©Áî®
  // Á∞°Áï•Âåñ„Åï„Çå„ÅüÂÆüË£Ö
  
  const plans: UpgradeRecommendation[] = [];
  const bottlenecks = analysis.bottlenecks;
  
  // 1. Á∑äÊÄ•ÂØæÂøú„Éó„É©„É≥
  if (bottlenecks.some(b => b.severity === 'critical')) {
    plans.push(createUrgentPlan(bottlenecks));
  }
  
  // 2. „Éê„É©„É≥„ÇπÈáçË¶ñ„Éó„É©„É≥
  plans.push(createBalancedPlan(bottlenecks));
  
  // 3. ‰∫àÁÆóÈáçË¶ñ„Éó„É©„É≥
  plans.push(createBudgetPlan(bottlenecks));
  
  // 4. ÊÄßËÉΩÈáçË¶ñ„Éó„É©„É≥
  plans.push(createPerformancePlan(bottlenecks));
  
  return plans.filter(Boolean);
}

async function performPlanComparison(plans: UpgradeRecommendation[]): Promise<ComparisonResult> {
  // „Éó„É©„É≥ÊØîËºÉÂàÜÊûêÂÆüË£Ö
  const metrics: ComparisonMetric[] = [
    {
      name: '„Ç≥„Çπ„Éà',
      key: 'totalCost',
      values: plans.map((plan, index) => ({
        planId: plan.id,
        value: plan.totalCost,
        rank: index + 1
      })),
      winner: plans.reduce((min, plan) => plan.totalCost < min.totalCost ? plan : min).id,
      importance: 0.8
    },
    {
      name: 'ÊÄßËÉΩÂêë‰∏ä',
      key: 'expectedImprovement.performanceGain',
      values: plans.map((plan, index) => ({
        planId: plan.id,
        value: plan.expectedImprovement.performanceGain,
        rank: index + 1
      })),
      winner: plans.reduce((max, plan) => plan.expectedImprovement.performanceGain > max.expectedImprovement.performanceGain ? plan : max).id,
      importance: 0.9
    }
  ];
  
  const ranking: PlanRanking[] = plans.map(plan => ({
    planId: plan.id,
    overallScore: calculateOverallScore(plan, metrics),
    categoryScores: {
      cost: normalizeCostScore(plan.totalCost, plans),
      performance: plan.expectedImprovement.performanceGain,
      roi: plan.roi.costPerformanceRatio * 50,
      feasibility: calculateFeasibilityScore(plan),
      risk: calculateRiskScore(plan)
    },
    reasoning: generateReasoningForPlan(plan)
  }));
  
  return {
    plans,
    metrics,
    ranking: ranking.sort((a, b) => b.overallScore - a.overallScore),
    tradeoffs: analyzeTradeoffs(plans),
    recommendation: generateRecommendation(ranking),
    confidence: 0.85
  };
}

async function createCustomPlan(analysis: BottleneckAnalysis, config: CustomPlanConfig): Promise<UpgradeRecommendation> {
  // „Ç´„Çπ„Çø„É†„Éó„É©„É≥ÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ
  const plan: UpgradeRecommendation = {
    id: `custom_${Date.now()}`,
    name: 'üéõÔ∏è „Ç´„Çπ„Çø„É†„Éó„É©„É≥',
    description: '„É¶„Éº„Ç∂„ÉºË®≠ÂÆö„Å´Âü∫„Å•„ÅèÊúÄÈÅ©Âåñ„Éó„É©„É≥',
    type: 'balanced',
    totalCost: config.budget.preferred,
    timeframe: `${config.timeframe.preferredDuration}„É∂Êúà`,
    difficultyLevel: config.constraints.maxComplexity,
    phases: [], // ÂÆüË£ÖÁ∞°Áï•Âåñ
    expectedImprovement: {
      performanceGain: calculateCustomImprovement(analysis, config),
      valueGain: 50,
      longevityExtension: config.timeframe.preferredDuration,
      powerEfficiencyGain: 10
    },
    roi: {
      costPerformanceRatio: 1.2,
      paybackPeriod: config.timeframe.preferredDuration,
      totalSavings: config.budget.preferred * 0.3,
      valueRetention: 0.75
    },
    risks: [],
    generatedAt: new Date(),
    confidence: 0.8,
    priority: calculateCustomPriority(config)
  };
  
  return plan;
}

// „Éó„É©„É≥ÁîüÊàê„Éò„É´„Éë„ÉºÈñ¢Êï∞Áæ§ÔºàÁ∞°Áï•ÂåñÂÆüË£ÖÔºâ
function createUrgentPlan(bottlenecks: any[]): UpgradeRecommendation {
  const critical = bottlenecks.filter(b => b.severity === 'critical');
  return {
    id: `urgent_${Date.now()}`,
    name: 'üö® Á∑äÊÄ•ÂØæÂøú„Éó„É©„É≥',
    description: 'ÈáçÂ§ßÂïèÈ°å„ÅÆÂç≥Â∫ßËß£Ê±∫',
    type: 'immediate',
    totalCost: critical.reduce((sum, b) => sum + b.costEstimate, 0),
    timeframe: 'Âç≥Â∫ßÂÆüË°å',
    difficultyLevel: 'moderate',
    phases: [],
    expectedImprovement: { performanceGain: 30, valueGain: 20, longevityExtension: 6, powerEfficiencyGain: 5 },
    roi: { costPerformanceRatio: 0.8, paybackPeriod: 3, totalSavings: 50000, valueRetention: 0.7 },
    risks: [],
    generatedAt: new Date(),
    confidence: 0.9,
    priority: 95
  };
}

function createBalancedPlan(bottlenecks: any[]): UpgradeRecommendation {
  return {
    id: `balanced_${Date.now()}`,
    name: '‚öñÔ∏è „Éê„É©„É≥„Çπ„Éó„É©„É≥',
    description: '„Ç≥„Çπ„Éà„Å®ÊÄßËÉΩ„ÅÆÊúÄÈÅ©„Éê„É©„É≥„Çπ',
    type: 'balanced',
    totalCost: 150000,
    timeframe: '3-6„É∂Êúà',
    difficultyLevel: 'moderate',
    phases: [],
    expectedImprovement: { performanceGain: 25, valueGain: 60, longevityExtension: 18, powerEfficiencyGain: 15 },
    roi: { costPerformanceRatio: 1.4, paybackPeriod: 8, totalSavings: 80000, valueRetention: 0.8 },
    risks: [],
    generatedAt: new Date(),
    confidence: 0.85,
    priority: 80
  };
}

function createBudgetPlan(bottlenecks: any[]): UpgradeRecommendation {
  return {
    id: `budget_${Date.now()}`,
    name: 'üí∞ ‰∫àÁÆóÈáçË¶ñ„Éó„É©„É≥',
    description: 'ÊúÄÂ∞è„Ç≥„Çπ„Éà„ÅßÊúÄÂ§ßÂäπÊûú',
    type: 'budget',
    totalCost: 80000,
    timeframe: 'ÊüîËªüÂÆüË°å',
    difficultyLevel: 'easy',
    phases: [],
    expectedImprovement: { performanceGain: 15, valueGain: 80, longevityExtension: 12, powerEfficiencyGain: 8 },
    roi: { costPerformanceRatio: 2.0, paybackPeriod: 4, totalSavings: 120000, valueRetention: 0.6 },
    risks: [],
    generatedAt: new Date(),
    confidence: 0.75,
    priority: 70
  };
}

function createPerformancePlan(bottlenecks: any[]): UpgradeRecommendation {
  return {
    id: `performance_${Date.now()}`,
    name: 'üöÄ ÊÄßËÉΩÈáçË¶ñ„Éó„É©„É≥',
    description: 'ÊúÄÈ´òÊÄßËÉΩËøΩÊ±Ç',
    type: 'performance',
    totalCost: 250000,
    timeframe: '6-12„É∂Êúà',
    difficultyLevel: 'advanced',
    phases: [],
    expectedImprovement: { performanceGain: 45, valueGain: 40, longevityExtension: 24, powerEfficiencyGain: 20 },
    roi: { costPerformanceRatio: 1.0, paybackPeriod: 12, totalSavings: 60000, valueRetention: 0.9 },
    risks: [],
    generatedAt: new Date(),
    confidence: 0.8,
    priority: 85
  };
}

// „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£Èñ¢Êï∞Áæ§
function calculateOverallScore(plan: UpgradeRecommendation, metrics: ComparisonMetric[]): number {
  return plan.priority; // Á∞°Áï•Âåñ
}

function normalizeCostScore(cost: number, allPlans: UpgradeRecommendation[]): number {
  const maxCost = Math.max(...allPlans.map(p => p.totalCost));
  const minCost = Math.min(...allPlans.map(p => p.totalCost));
  return 100 - ((cost - minCost) / (maxCost - minCost)) * 100;
}

function calculateFeasibilityScore(plan: UpgradeRecommendation): number {
  const difficultyScores = { easy: 90, moderate: 75, difficult: 60, expert: 40 };
  return difficultyScores[plan.difficultyLevel] || 50;
}

function calculateRiskScore(plan: UpgradeRecommendation): number {
  return Math.max(0, 100 - (plan.risks.length * 20));
}

function generateReasoningForPlan(plan: UpgradeRecommendation): string[] {
  return [`${plan.name}„ÅØ${plan.description}„ÇíÈáçË¶ñ`, `‰∫àÊÉ≥ÊîπÂñÑÂäπÊûú: ${plan.expectedImprovement.performanceGain}%`];
}

function analyzeTradeoffs(plans: UpgradeRecommendation[]): TradeoffAnalysis[] {
  return [{
    aspect1: '„Ç≥„Çπ„Éà',
    aspect2: 'ÊÄßËÉΩ',
    correlation: -0.6,
    description: '„Ç≥„Çπ„Éà„Å®ÊÄßËÉΩ„ÅØÊ¶Ç„Å≠ÈÄÜÁõ∏Èñ¢„ÅÆÈñ¢‰øÇ',
    recommendations: ['‰∫àÁÆó„Å´Âøú„Åò„ÅüÊúÄÈÅ©„Éê„É©„É≥„ÇπÈÅ∏Êäû„ÇíÊé®Â•®']
  }];
}

function generateRecommendation(ranking: PlanRanking[]): string {
  const topPlan = ranking[0];
  return `Á∑èÂêàË©ï‰æ°„ÅåÊúÄ„ÇÇÈ´ò„ÅÑ„Äå${topPlan.planId}„Äç„ÇíÊé®Â•®„Åó„Åæ„Åô`;
}

function calculateCustomImprovement(analysis: BottleneckAnalysis, config: CustomPlanConfig): number {
  const budgetFactor = config.budget.preferred / 150000; // 15‰∏áÂÜÜÂü∫Ê∫ñ
  const performancePriority = config.priority.performance / 100;
  const baseImprovement = analysis.bottlenecks.length * 8;
  
  return Math.min(baseImprovement * budgetFactor * performancePriority * 1.5, 60);
}

function calculateCustomPriority(config: CustomPlanConfig): number {
  return (config.priority.performance + config.priority.efficiency) / 2;
}

export default useUpgradePlanner;